// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.7.3;

interface IUniswap {
  function swapExactTokensForETH(
    uint amountIn,
    uint amountOutMin,
    address[] calldata path,
    address to,
    uint deadline)
    external
    returns (uint[] memory amounts);
  function swapExactETHForTokens(
    uint amountOutMin,
    address[] calldata path,
    address to,
    uint deadline)
    external
    payable
    returns (uint[] memory amounts);
  function WETH() external pure returns (address);
  function getAmountsOut(uint amountIn, address[] memory path) external view returns (uint[] memory amounts);

}

contract permitSwap {
    IUniswap uniswap;

    // Mainnet Uniswap Router: 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D
    constructor(address _uniswap) {
        uniswap = IUniswap(_uniswap);
    }

    /**
    Costs of transaction are shifted from owner (signature giver) to spender (signature receiver).
    Contract is signature receiver and pays for transaction from it's balance after yanking allowance from owner. 
    Contract needs to receive signature from owner and transfer.
    Upon receive of signature, swapTokensForETH should be called with owner Tokens
    */

    function swapTokensForEth(address token, uint amountIn, uint deadline) external payable{
        IERC20(token).transferFrom(msg.sender, address(this), amountIn);

        address[] memory path = new address[](2);
        path[0] = token;
        path[1] = uniswap.WETH();

        IERC20(token).approve(address(uniswap), amountIn);

        // https://uniswap.org/docs/v2/smart-contracts/library/#getamountout
        uint[] memory amountOutMin = getEstimatedTokenForETH(amountIn, path);

        uniswap.swapExactTokensForETH(
        amountIn,
        amountOutMin[1],
        path,
        msg.sender,
        deadline
        );
  }

    function getEstimatedTokenForETH(uint amountIn , address[] memory path) public view returns (uint[] memory) {
        return uniswap.getAmountsOut(amountIn, path);
    }
}